"use strict";(self.webpackChunkvoltaris_website=self.webpackChunkvoltaris_website||[]).push([[96],{146:(t,e,n)=>{n.d(e,{$J:()=>a,BE:()=>u,Gm:()=>o,Ne:()=>l,Q7:()=>r,Xe:()=>i,bf:()=>d,nw:()=>c,vl:()=>f,yj:()=>s});const r=0,o=1,i=2,s=2,a=1.25,c=1,l=32,u=65535,d=Math.pow(2,-24),f=Symbol("SKIP_GENERATION")},7674:(t,e,n)=>{n.d(e,{zQ:()=>Se,LO:()=>Fe,je:()=>_e});var r=n(9408);function o(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t)}var i=n(146);function s(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function a(t,e){if(!t.index){const n=t.attributes.position.count,o=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ArrayBuffer;return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new r.BufferAttribute(o,1));for(let t=0;t<n;t++)o[t]=t}}function c(t){const e=s(t),n=t.drawRange,r=n.start/3,o=(n.start+n.count)/3,i=Math.max(0,r),a=Math.min(e,o)-i;return[{offset:Math.floor(i),count:Math.floor(a)}]}function l(t){if(!t.groups||!t.groups.length)return c(t);const e=[],n=new Set,r=t.drawRange,o=r.start/3,i=(r.start+r.count)/3;for(const a of t.groups){const t=a.start/3,e=(a.start+a.count)/3;n.add(Math.max(o,t)),n.add(Math.min(i,e))}const s=Array.from(n.values()).sort(((t,e)=>t-e));for(let a=0;a<s.length-1;a++){const t=s[a],n=s[a+1];e.push({offset:Math.floor(t),count:Math.floor(n-t)})}return e}function u(t,e,n,r,o){let i=1/0,s=1/0,a=1/0,c=-1/0,l=-1/0,u=-1/0,d=1/0,f=1/0,p=1/0,h=-1/0,y=-1/0,g=-1/0;for(let x=6*e,m=6*(e+n);x<m;x+=6){const e=t[x+0],n=t[x+1],r=e-n,o=e+n;r<i&&(i=r),o>c&&(c=o),e<d&&(d=e),e>h&&(h=e);const m=t[x+2],w=t[x+3],B=m-w,v=m+w;B<s&&(s=B),v>l&&(l=v),m<f&&(f=m),m>y&&(y=m);const b=t[x+4],A=t[x+5],T=b-A,P=b+A;T<a&&(a=T),P>u&&(u=P),b<p&&(p=b),b>g&&(g=b)}r[0]=i,r[1]=s,r[2]=a,r[3]=c,r[4]=l,r[5]=u,o[0]=d,o[1]=f,o[2]=p,o[3]=h,o[4]=y,o[5]=g}function d(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function f(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const o=t[r+3]-t[r];o>n&&(n=o,e=r)}return e}function p(t,e){e.set(t)}function h(t,e,n){let r,o;for(let i=0;i<3;i++){const s=i+3;r=t[i],o=e[i],n[i]=r<o?r:o,r=t[s],o=e[s],n[s]=r>o?r:o}}function y(t,e,n){for(let r=0;r<3;r++){const o=e[t+2*r],i=e[t+2*r+1],s=o-i,a=o+i;s<n[r]&&(n[r]=s),a>n[r+3]&&(n[r+3]=a)}}function g(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}const x=32,m=(t,e)=>t.candidate-e.candidate,w=new Array(x).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),B=new Float32Array(6);class v{constructor(){this.boundingData=new Float32Array(6)}}function b(t,e,n,r,o,i){let s=r,a=r+o-1;const c=i.pos,l=2*i.axis;for(;;){for(;s<=a&&n[6*s+l]<c;)s++;for(;s<=a&&n[6*a+l]>=c;)a--;if(!(s<a))return s;for(let t=0;t<3;t++){let n=e[3*s+t];e[3*s+t]=e[3*a+t],e[3*a+t]=n}for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}function A(t,e,n,r,o,i){let s=r,a=r+o-1;const c=i.pos,l=2*i.axis;for(;;){for(;s<=a&&n[6*s+l]<c;)s++;for(;s<=a&&n[6*a+l]>=c;)a--;if(!(s<a))return s;{let e=t[s];t[s]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}}function T(t,e){return 65535===e[t+15]}function P(t,e){return e[t+6]}function M(t,e){return e[t+14]}function V(t){return t+8}function U(t,e){return e[t+6]}function S(t,e){return e[t+7]}let F,_,I,z;const q=Math.pow(2,32);function C(t){return"count"in t?1:1+C(t.left)+C(t.right)}function E(t,e,n){return F=new Float32Array(n),_=new Uint32Array(n),I=new Uint16Array(n),z=new Uint8Array(n),L(t,e)}function L(t,e){const n=t/4,r=t/2,o="count"in e,s=e.boundingData;for(let i=0;i<6;i++)F[n+i]=s[i];if(o){if(e.buffer){const r=e.buffer;z.set(new Uint8Array(r),t);for(let e=t,o=t+r.byteLength;e<o;e+=i.Ne){T(e/2,I)||(_[e/4+6]+=n)}return t+r.byteLength}{const o=e.offset,s=e.count;return _[n+6]=o,I[r+14]=s,I[r+15]=i.BE,t+i.Ne}}{const r=e.left,o=e.right,s=e.splitAxis;let a;if(a=L(t+i.Ne,r),a/4>q)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return _[n+6]=a/4,a=L(a,o),_[n+7]=s,a}}function N(t,e,n,r,o){const{maxDepth:a,verbose:c,maxLeafTris:l,strategy:d,onProgress:T,indirect:P}=o,M=t._indirectBuffer,V=t.geometry,U=V.index?V.index.array:null,S=P?A:b,F=s(V),_=new Float32Array(6);let I=!1;const z=new v;return u(e,n,r,z.boundingData,_),function t(n,r,o){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;!I&&b>=a&&(I=!0,c&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(V)));if(o<=l||b>=a)return q(r+o),n.offset=r,n.count=o,n;const A=function(t,e,n,r,o,s){let a=-1,c=0;if(s===i.Q7)a=f(e),-1!==a&&(c=(e[a]+e[a+3])/2);else if(s===i.Gm)a=f(t),-1!==a&&(c=function(t,e,n,r){let o=0;for(let i=e,s=e+n;i<s;i++)o+=t[6*i+2*r];return o/n}(n,r,o,a));else if(s===i.Xe){const s=g(t);let l=i.$J*o;const u=6*r,d=6*(r+o);for(let t=0;t<3;t++){const r=e[t],f=(e[t+3]-r)/x;if(o<8){const e=[...w];e.length=o;let r=0;for(let o=u;o<d;o+=6,r++){const i=e[r];i.candidate=n[o+2*t],i.count=0;const{bounds:s,leftCacheBounds:a,rightCacheBounds:c}=i;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;y(o,n,s)}e.sort(m);let f=o;for(let t=0;t<f;t++){const n=e[t];for(;t+1<f&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),f--}for(let o=u;o<d;o+=6){const r=n[o+2*t];for(let t=0;t<f;t++){const i=e[t];r>=i.candidate?y(o,n,i.rightCacheBounds):(y(o,n,i.leftCacheBounds),i.count++)}}for(let n=0;n<f;n++){const r=e[n],u=r.count,d=o-r.count,f=r.leftCacheBounds,p=r.rightCacheBounds;let h=0;0!==u&&(h=g(f)/s);let y=0;0!==d&&(y=g(p)/s);const x=i.nw+i.$J*(h*u+y*d);x<l&&(a=t,l=x,c=r.candidate)}}else{for(let t=0;t<x;t++){const e=w[t];e.count=0,e.candidate=r+f+t*f;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let o=u;o<d;o+=6){let e=~~((n[o+2*t]-r)/f);e>=x&&(e=31);const i=w[e];i.count++,y(o,n,i.bounds)}const e=w[31];p(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=w[t],n=w[t+1];h(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let m=0;for(let n=0;n<31;n++){const e=w[n],r=e.count,u=e.bounds,d=w[n+1].rightCacheBounds;0!==r&&(0===m?p(u,B):h(u,B,B)),m+=r;let f=0,y=0;0!==m&&(f=g(B)/s);const x=o-m;0!==x&&(y=g(d)/s);const v=i.nw+i.$J*(f*m+y*x);v<l&&(a=t,l=v,c=e.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${s} used.`);return{axis:a,pos:c}}(n.boundingData,s,e,r,o,d);if(-1===A.axis)return q(r+o),n.offset=r,n.count=o,n;const T=S(M,U,e,r,o,A);if(T===r||T===r+o)q(r+o),n.offset=r,n.count=o;else{n.splitAxis=A.axis;const i=new v,s=r,a=T-r;n.left=i,u(e,s,a,i.boundingData,_),t(i,s,a,_,b+1);const c=new v,l=T,d=o-a;n.right=c,u(e,l,d,c.boundingData,_),t(c,l,d,_,b+1)}return n}(z,n,r,_),z;function q(t){T&&T(t/F)}}function X(t,e){const n=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,r=n>65536,o=r?4:2,i=e?new SharedArrayBuffer(n*o):new ArrayBuffer(n*o),s=r?new Uint32Array(i):new Uint16Array(i);for(let a=0,c=s.length;a<c;a++)s[a]=a;return s}(n,e.useSharedArrayBuffer),function(t){if(0===t.groups.length)return!1;const e=s(t),n=l(t).sort(((t,e)=>t.offset-e.offset)),r=n[n.length-1];r.count=Math.min(e-r.offset,r.count);let o=0;return n.forEach((t=>{let{count:e}=t;return o+=e})),e!==o}(n)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||a(n,e);const r=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o=t.attributes.position,a=t.index?t.index.array:null,c=s(t),l=o.normalized;let u;null===e?(u=new Float32Array(6*c*4),n=0,r=c):(u=e,n=n||0,r=r||c);const d=o.array,f=o.offset||0;let p=3;o.isInterleavedBufferAttribute&&(p=o.data.stride);const h=["getX","getY","getZ"];for(let s=n;s<n+r;s++){const t=3*s,e=6*s;let n=t+0,r=t+1,c=t+2;a&&(n=a[n],r=a[r],c=a[c]),l||(n=n*p+f,r=r*p+f,c=c*p+f);for(let s=0;s<3;s++){let t,a,f;l?(t=o[h[s]](n),a=o[h[s]](r),f=o[h[s]](c)):(t=d[n+s],a=d[r+s],f=d[c+s]);let p=t;a<p&&(p=a),f<p&&(p=f);let y=t;a>y&&(y=a),f>y&&(y=f);const g=(y-p)/2,x=2*s;u[e+x+0]=p+g,u[e+x+1]=g+(Math.abs(p)+g)*i.bf}}return u}(n),u=e.indirect?c(n):l(n);t._roots=u.map((n=>{const s=N(t,o,n.offset,n.count,e),a=C(s),c=new r(i.Ne*a);return E(0,s,c),c}))}class O{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let o=0,i=t.length;o<i;o++){const i=t[o][e];n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let o=0,i=e.length;o<i;o++){const i=e[o],s=t.dot(i);n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}O.prototype.setFromBox=function(){const t=new r.Vector3;return function(e,n){const r=n.min,o=n.max;let i=1/0,s=-1/0;for(let a=0;a<=1;a++)for(let n=0;n<=1;n++)for(let c=0;c<=1;c++){t.x=r.x*a+o.x*(1-a),t.y=r.y*n+o.y*(1-n),t.z=r.z*c+o.z*(1-c);const l=e.dot(t);i=Math.min(l,i),s=Math.max(l,s)}this.min=i,this.max=s}}();!function(){const t=new O}();const k=function(){const t=new r.Vector3,e=new r.Vector3,n=new r.Vector3;return function(r,o,i){const s=r.start,a=t,c=o.start,l=e;n.subVectors(s,c),t.subVectors(r.end,r.start),e.subVectors(o.end,o.start);const u=n.dot(l),d=l.dot(a),f=l.dot(l),p=n.dot(a),h=a.dot(a)*f-d*d;let y,g;y=0!==h?(u*d-p*f)/h:0,g=(u+y*d)/f,i.x=y,i.y=g}}(),H=function(){const t=new r.Vector2,e=new r.Vector3,n=new r.Vector3;return function(r,o,i,s){k(r,o,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return r.at(a,i),void o.at(c,s);if(a>=0&&a<=1)return c<0?o.at(0,s):o.at(1,s),void r.closestPointToPoint(s,!0,i);if(c>=0&&c<=1)return a<0?r.at(0,i):r.at(1,i),void o.closestPointToPoint(i,!0,s);{let t,l;t=a<0?r.start:r.end,l=c<0?o.start:o.end;const u=e,d=n;return r.closestPointToPoint(l,!0,e),o.closestPointToPoint(t,!0,n),u.distanceToSquared(l)<=d.distanceToSquared(t)?(i.copy(u),void s.copy(l)):(i.copy(t),void s.copy(d))}}}(),R=function(){const t=new r.Vector3,e=new r.Vector3,n=new r.Plane,o=new r.Line3;return function(r,i){const{radius:s,center:a}=r,{a:c,b:l,c:u}=i;o.start=c,o.end=l;if(o.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;o.start=c,o.end=u;if(o.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;o.start=l,o.end=u;if(o.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;const d=i.getPlane(n);if(Math.abs(d.distanceToPoint(a))<=s){const t=d.projectPoint(a,e);if(i.containsPoint(t))return!0}return!1}}();function D(t){return Math.abs(t)<1e-15}class j extends r.Triangle{constructor(){super(...arguments),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new r.Vector3)),this.satBounds=new Array(4).fill().map((()=>new O)),this.points=[this.a,this.b,this.c],this.sphere=new r.Sphere,this.plane=new r.Plane,this.needsUpdate=!0}intersectsSphere(t){return R(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,o=this.satAxes,i=this.satBounds,s=o[0],a=i[0];this.getNormal(s),a.setFromPoints(s,r);const c=o[1],l=i[1];c.subVectors(t,e),l.setFromPoints(c,r);const u=o[2],d=i[2];u.subVectors(e,n),d.setFromPoints(u,r);const f=o[3],p=i[3];f.subVectors(n,t),p.setFromPoints(f,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,t),this.needsUpdate=!1}}j.prototype.closestPointToSegment=function(){const t=new r.Vector3,e=new r.Vector3,n=new r.Line3;return function(r){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const{start:s,end:a}=r,c=this.points;let l,u=1/0;for(let d=0;d<3;d++){const s=(d+1)%3;n.start.copy(c[d]),n.end.copy(c[s]),H(n,r,t,e),l=t.distanceToSquared(e),l<u&&(u=l,o&&o.copy(t),i&&i.copy(e))}return this.closestPointToPoint(s,t),l=s.distanceToSquared(t),l<u&&(u=l,o&&o.copy(t),i&&i.copy(s)),this.closestPointToPoint(a,t),l=a.distanceToSquared(t),l<u&&(u=l,o&&o.copy(t),i&&i.copy(a)),Math.sqrt(u)}}(),j.prototype.intersectsTriangle=function(){const t=new j,e=new Array(3),n=new Array(3),o=new O,i=new O,s=new r.Vector3,a=new r.Vector3,c=new r.Vector3,l=new r.Vector3,u=new r.Vector3,d=new r.Line3,f=new r.Line3,p=new r.Line3,h=new r.Vector3;function y(t,e,n){const r=t.points;let o=0,i=-1;for(let s=0;s<3;s++){const{start:t,end:c}=d;t.copy(r[s]),c.copy(r[(s+1)%3]),d.delta(a);const l=D(e.distanceToPoint(t));if(D(e.normal.dot(a))&&l){n.copy(d),o=2;break}const u=e.intersectLine(d,h);if(!u&&l&&h.copy(t),(u||l)&&!D(h.distanceTo(c))){if(o<=1){(1===o?n.start:n.end).copy(h),l&&(i=o)}else if(o>=2){(1===i?n.start:n.end).copy(h),o=2;break}if(o++,2===o&&-1===i)break}}return o}return function(r){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,d=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const h=this.plane,g=r.plane;if(Math.abs(h.normal.dot(g.normal))>1-1e-10){const t=this.satBounds,c=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let e=0;e<4;e++){const r=t[e],i=c[e];if(o.setFromPoints(i,n),r.isSeparated(o))return!1}const l=r.satBounds,u=r.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let n=0;n<4;n++){const t=l[n],r=u[n];if(o.setFromPoints(r,e),t.isSeparated(o))return!1}for(let r=0;r<4;r++){const t=c[r];for(let r=0;r<4;r++){const a=u[r];if(s.crossVectors(t,a),o.setFromPoints(s,e),i.setFromPoints(s,n),o.isSeparated(i))return!1}}return a&&(d||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),a.start.set(0,0,0),a.end.set(0,0,0)),!0}{const t=y(this,g,f);if(1===t&&r.containsPoint(f.end))return a&&(a.start.copy(f.end),a.end.copy(f.end)),!0;if(2!==t)return!1;const e=y(r,h,p);if(1===e&&this.containsPoint(p.end))return a&&(a.start.copy(p.end),a.end.copy(p.end)),!0;if(2!==e)return!1;if(f.delta(c),p.delta(l),c.dot(l)<0){let t=p.start;p.start=p.end,p.end=t}const n=f.start.dot(c),o=f.end.dot(c),i=p.start.dot(c),s=p.end.dot(c);return(n===s||i===o||o<i!==n<s)&&(a&&(u.subVectors(f.start,p.start),u.dot(c)>0?a.start.copy(f.start):a.start.copy(p.start),u.subVectors(f.end,p.end),u.dot(c)<0?a.end.copy(f.end):a.end.copy(p.end)),!0)}}}(),j.prototype.distanceToPoint=function(){const t=new r.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),j.prototype.distanceToTriangle=function(){const t=new r.Vector3,e=new r.Vector3,n=["a","b","c"],o=new r.Line3,i=new r.Line3;return function(r){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const c=s||a?o:null;if(this.intersectsTriangle(r,c))return(s||a)&&(s&&c.getCenter(s),a&&c.getCenter(a)),0;let l=1/0;for(let e=0;e<3;e++){let o;const i=n[e],c=r[i];this.closestPointToPoint(c,t),o=c.distanceToSquared(t),o<l&&(l=o,s&&s.copy(t),a&&a.copy(c));const u=this[i];r.closestPointToPoint(u,t),o=u.distanceToSquared(t),o<l&&(l=o,s&&s.copy(u),a&&a.copy(t))}for(let u=0;u<3;u++){const c=n[u],d=n[(u+1)%3];o.set(this[c],this[d]);for(let u=0;u<3;u++){const c=n[u],d=n[(u+1)%3];i.set(r[c],r[d]),H(o,i,t,e);const f=t.distanceToSquared(e);f<l&&(l=f,s&&s.copy(t),a&&a.copy(e))}}return Math.sqrt(l)}}();class G{constructor(t,e,n){this.isOrientedBox=!0,this.min=new r.Vector3,this.max=new r.Vector3,this.matrix=new r.Matrix4,this.invMatrix=new r.Matrix4,this.points=new Array(8).fill().map((()=>new r.Vector3)),this.satAxes=new Array(3).fill().map((()=>new r.Vector3)),this.satBounds=new Array(3).fill().map((()=>new O)),this.alignedSatBounds=new Array(3).fill().map((()=>new O)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}G.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let c=0;c<=1;c++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=r[1*c|2*o|4*i];s.x=c?n.x:e.x,s.y=o?n.y:e.y,s.z=i?n.z:e.z,s.applyMatrix4(t)}const o=this.satBounds,i=this.satAxes,s=r[0];for(let c=0;c<3;c++){const t=i[c],e=o[c],n=r[1<<c];t.subVectors(s,n),e.setFromPoints(t,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},G.prototype.intersectsBox=function(){const t=new O;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,o=this.satBounds,i=this.satAxes,s=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,s[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,s[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,s[2].isSeparated(t))return!1;for(let a=0;a<3;a++){const n=i[a],r=o[a];if(t.setFromBox(n,e),r.isSeparated(t))return!1}return!0}}(),G.prototype.intersectsTriangle=function(){const t=new j,e=new Array(3),n=new O,o=new O,i=new r.Vector3;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const s=this.satBounds,a=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let t=0;t<3;t++){const r=s[t],o=a[t];if(n.setFromPoints(o,e),r.isSeparated(n))return!1}const c=r.satBounds,l=r.satAxes,u=this.points;for(let t=0;t<3;t++){const e=c[t],r=l[t];if(n.setFromPoints(r,u),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const r=a[t];for(let t=0;t<4;t++){const s=l[t];if(i.crossVectors(r,s),n.setFromPoints(i,e),o.setFromPoints(i,u),n.isSeparated(o))return!1}}return!0}}(),G.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},G.prototype.distanceToPoint=function(){const t=new r.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),G.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new r.Line3)),n=new Array(12).fill().map((()=>new r.Line3)),o=new r.Vector3,i=new r.Vector3;return function(r){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(a||c)&&(r.getCenter(i),this.closestPointToPoint(i,o),r.closestPointToPoint(o,i),a&&a.copy(o),c&&c.copy(i)),0;const l=s*s,u=r.min,d=r.max,f=this.points;let p=1/0;for(let t=0;t<8;t++){const e=f[t];i.copy(e).clamp(u,d);const n=e.distanceToSquared(i);if(n<p&&(p=n,a&&a.copy(e),c&&c.copy(i),n<l))return Math.sqrt(n)}let h=0;for(let o=0;o<3;o++)for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){const s=(o+1)%3,a=(o+2)%3,c=1<<o|r<<s|i<<a,l=f[r<<s|i<<a],p=f[c];e[h].set(l,p);const y=t[o],g=t[s],x=t[a],m=n[h],w=m.start,B=m.end;w[y]=u[y],w[g]=r?u[g]:d[g],w[x]=i?u[x]:d[g],B[y]=d[y],B[g]=r?u[g]:d[g],B[x]=i?u[x]:d[g],h++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){i.x=t?d.x:u.x,i.y=e?d.y:u.y,i.z=n?d.z:u.z,this.closestPointToPoint(i,o);const r=i.distanceToSquared(o);if(r<p&&(p=r,a&&a.copy(o),c&&c.copy(i),r<l))return Math.sqrt(r)}for(let t=0;t<12;t++){const r=e[t];for(let t=0;t<12;t++){const e=n[t];H(r,e,o,i);const s=o.distanceToSquared(i);if(s<p&&(p=s,a&&a.copy(o),c&&c.copy(i),s<l))return Math.sqrt(s)}}return Math.sqrt(p)}}();class Y{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Z extends Y{constructor(){super((()=>new j))}}const $=new Z;const J=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let Q,W;const K=[],tt=new Y((()=>new r.Box3));function et(t,e,n,r,o,i){Q=tt.getPrimitive(),W=tt.getPrimitive(),K.push(Q,W),J.setBuffer(t._roots[e]);const s=nt(0,t.geometry,n,r,o,i);J.clearBuffer(),tt.releasePrimitive(Q),tt.releasePrimitive(W),K.pop(),K.pop();const a=K.length;return a>0&&(W=K[a-1],Q=K[a-2]),s}function nt(t,e,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const{float32Array:c,uint16Array:l,uint32Array:u}=J;let f=2*t;if(T(f,l)){const p=P(t,u),h=M(f,l);return d(t,c,Q),r(p,h,!1,a,s+t,Q)}{const y=V(t),g=U(t,u);let x,m,w,B,v=y,b=g;if(o&&(w=Q,B=W,d(v,c,w),d(b,c,B),x=o(w),m=o(B),m<x)){v=g,b=y;const q=x;x=m,m=q,w=B}w||(w=Q,d(v,c,w));const A=n(w,T(2*v,l),x,a+1,s+v);let S;if(A===i.yj){const C=I(v);S=r(C,z(v)-C,!0,a+1,s+v,w)}else S=A&&nt(v,e,n,r,o,s,a+1);if(S)return!0;B=W,d(b,c,B);const F=n(B,T(2*b,l),m,a+1,s+b);let _;if(F===i.yj){const E=I(b);_=r(E,z(b)-E,!0,a+1,s+b,B)}else _=F&&nt(b,e,n,r,o,s,a+1);return!!_;function I(t){const{uint16Array:e,uint32Array:n}=J;let r=2*t;for(;!T(r,e);)r=2*(t=V(t));return P(t,n)}function z(t){const{uint16Array:e,uint32Array:n}=J;let r=2*t;for(;!T(r,e);)r=2*(t=U(t,n));return P(t,n)+M(r,e)}}}const rt=new r.Vector3,ot=new r.Vector3;const it=new r.Vector3,st=new r.Vector3,at=new r.Vector3,ct=new r.Vector2,lt=new r.Vector2,ut=new r.Vector2,dt=new r.Vector3,ft=new r.Vector3,pt=new r.Vector3,ht=new r.Vector3;function yt(t,e,n,o,i,s,a,c,l,u,d){it.fromBufferAttribute(e,s),st.fromBufferAttribute(e,a),at.fromBufferAttribute(e,c);const f=function(t,e,n,o,i,s,a,c){let l;if(l=s===r.BackSide?t.intersectTriangle(o,n,e,!0,i):t.intersectTriangle(e,n,o,s!==r.DoubleSide,i),null===l)return null;const u=t.origin.distanceTo(i);return u<a||u>c?null:{distance:u,point:i.clone()}}(t,it,st,at,ht,l,u,d);if(f){o&&(ct.fromBufferAttribute(o,s),lt.fromBufferAttribute(o,a),ut.fromBufferAttribute(o,c),f.uv=r.Triangle.getInterpolation(ht,it,st,at,ct,lt,ut,new r.Vector2)),i&&(ct.fromBufferAttribute(i,s),lt.fromBufferAttribute(i,a),ut.fromBufferAttribute(i,c),f.uv1=r.Triangle.getInterpolation(ht,it,st,at,ct,lt,ut,new r.Vector2)),n&&(dt.fromBufferAttribute(n,s),ft.fromBufferAttribute(n,a),pt.fromBufferAttribute(n,c),f.normal=r.Triangle.getInterpolation(ht,it,st,at,dt,ft,pt,new r.Vector3),f.normal.dot(t.direction)>0&&f.normal.multiplyScalar(-1));const e={a:s,b:a,c:c,normal:new r.Vector3,materialIndex:0};r.Triangle.getNormal(it,st,at,e.normal),f.face=e,f.faceIndex=s}return f}function gt(t,e,n,r,o,i,s){const a=3*r;let c=a+0,l=a+1,u=a+2;const d=t.index;t.index&&(c=d.getX(c),l=d.getX(l),u=d.getX(u));const{position:f,normal:p,uv:h,uv1:y}=t.attributes,g=yt(n,f,p,h,y,c,l,u,e,i,s);return g?(g.faceIndex=r,o&&o.push(g),g):null}function xt(t,e,n,r){const o=t.a,i=t.b,s=t.c;let a=e,c=e+1,l=e+2;n&&(a=n.getX(a),c=n.getX(c),l=n.getX(l)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),i.x=r.getX(c),i.y=r.getY(c),i.z=r.getZ(c),s.x=r.getX(l),s.y=r.getY(l),s.z=r.getZ(l)}function mt(t,e,n,r,o,i,s){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let u=t,d=e+t;u<d;u++){let t;if(t=u,xt(s,3*t,c,l),s.needsUpdate=!0,r(s,t,o,i))return!0}return!1}function wt(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let s,a,c,l,u=0;const d=t._roots;for(let i=0,p=d.length;i<p;i++)s=d[i],a=new Uint32Array(s),c=new Uint16Array(s),l=new Float32Array(s),f(0,u),u+=s.byteLength;function f(t,n){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const u=2*t;if(c[u+15]===i.BE){const e=a[t+6];let n=1/0,i=1/0,s=1/0,d=-1/0,f=-1/0,p=-1/0;for(let t=3*e,a=3*(e+c[u+14]);t<a;t++){let e=r[t];const a=o.getX(e),c=o.getY(e),l=o.getZ(e);a<n&&(n=a),a>d&&(d=a),c<i&&(i=c),c>f&&(f=c),l<s&&(s=l),l>p&&(p=l)}return(l[t+0]!==n||l[t+1]!==i||l[t+2]!==s||l[t+3]!==d||l[t+4]!==f||l[t+5]!==p)&&(l[t+0]=n,l[t+1]=i,l[t+2]=s,l[t+3]=d,l[t+4]=f,l[t+5]=p,!0)}{const r=t+8,o=a[t+6],i=r+n,c=o+n;let u=s,d=!1,p=!1;e?u||(d=e.has(i),p=e.has(c),u=!d&&!p):(d=!0,p=!0);const h=u||p;let y=!1;(u||d)&&(y=f(r,n,u));let g=!1;h&&(g=f(o,n,u));const x=y||g;if(x)for(let e=0;e<3;e++){const n=r+e,i=o+e,s=l[n],a=l[n+3],c=l[i],u=l[i+3];l[t+e]=s<c?s:c,l[t+e+3]=a>u?a:u}return x}}}function Bt(t,e,n,r,o){let i,s,a,c,l,u;const d=1/n.direction.x,f=1/n.direction.y,p=1/n.direction.z,h=n.origin.x,y=n.origin.y,g=n.origin.z;let x=e[t],m=e[t+3],w=e[t+1],B=e[t+3+1],v=e[t+2],b=e[t+3+2];return d>=0?(i=(x-h)*d,s=(m-h)*d):(i=(m-h)*d,s=(x-h)*d),f>=0?(a=(w-y)*f,c=(B-y)*f):(a=(B-y)*f,c=(w-y)*f),!(i>c||a>s)&&((a>i||isNaN(i))&&(i=a),(c<s||isNaN(s))&&(s=c),p>=0?(l=(v-g)*p,u=(b-g)*p):(l=(b-g)*p,u=(v-g)*p),!(i>u||l>s)&&((l>i||i!==i)&&(i=l),(u<s||s!==s)&&(s=u),i<=o&&s>=r))}function vt(t,e,n,r,o,i,s){J.setBuffer(t._roots[e]),bt(0,t,n,r,o,i,s),J.clearBuffer()}function bt(t,e,n,r,o,i,s){const{float32Array:a,uint16Array:c,uint32Array:l}=J,u=2*t;if(T(u,c)){!function(t,e,n,r,o,i,s,a){const{geometry:c,_indirectBuffer:l}=t;for(let u=r,d=r+o;u<d;u++)gt(c,e,n,u,i,s,a)}(e,n,r,P(t,l),M(u,c),o,i,s)}else{const c=V(t);Bt(c,a,r,i,s)&&bt(c,e,n,r,o,i,s);const u=U(t,l);Bt(u,a,r,i,s)&&bt(u,e,n,r,o,i,s)}}const At=["x","y","z"];function Tt(t,e,n,r,o,i){J.setBuffer(t._roots[e]);const s=Pt(0,t,n,r,o,i);return J.clearBuffer(),s}function Pt(t,e,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:c}=J;let l=2*t;if(T(l,a)){return function(t,e,n,r,o,i,s){const{geometry:a,_indirectBuffer:c}=t;let l=1/0,u=null;for(let d=r,f=r+o;d<f;d++){let t;t=gt(a,e,n,d,null,i,s),t&&t.distance<l&&(u=t,l=t.distance)}return u}(e,n,r,P(t,c),M(l,a),o,i)}{const a=S(t,c),l=At[a],u=r.direction[l]>=0;let d,f;u?(d=V(t),f=U(t,c)):(d=U(t,c),f=V(t));const p=Bt(d,s,r,o,i)?Pt(d,e,n,r,o,i):null;if(p){const t=p.point[l];if(u?t<=s[f+a]:t>=s[f+a+3])return p}const h=Bt(f,s,r,o,i)?Pt(f,e,n,r,o,i):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const Mt=new r.Box3,Vt=new j,Ut=new j,St=new r.Matrix4,Ft=new G,_t=new G;function It(t,e,n,r){J.setBuffer(t._roots[e]);const o=zt(0,t,n,r);return J.clearBuffer(),o}function zt(t,e,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const{float32Array:i,uint16Array:s,uint32Array:a}=J;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),Ft.set(n.boundingBox.min,n.boundingBox.max,r),o=Ft);if(!T(c,s)){const s=t+8,c=a[t+6];d(s,i,Mt);if(o.intersectsBox(Mt)&&zt(s,e,n,r,o))return!0;d(c,i,Mt);return!!(o.intersectsBox(Mt)&&zt(c,e,n,r,o))}{const o=e.geometry,l=o.index,u=o.attributes.position,f=n.index,p=n.attributes.position,h=P(t,a),y=M(c,s);if(St.copy(r).invert(),n.boundsTree){d(t,i,_t),_t.matrix.copy(St),_t.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>_t.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*h,n=3*(y+h);e<n;e+=3)if(xt(Ut,e,l,u),Ut.needsUpdate=!0,t.intersectsTriangle(Ut))return!0;return!1}})}for(let t=3*h,e=3*(y+h);t<e;t+=3){xt(Vt,t,l,u),Vt.a.applyMatrix4(St),Vt.b.applyMatrix4(St),Vt.c.applyMatrix4(St),Vt.needsUpdate=!0;for(let t=0,e=f.count;t<e;t+=3)if(xt(Ut,t,f,p),Ut.needsUpdate=!0,Vt.intersectsTriangle(Ut))return!0}}}const qt=new r.Matrix4,Ct=new G,Et=new G,Lt=new r.Vector3,Nt=new r.Vector3,Xt=new r.Vector3,Ot=new r.Vector3;function kt(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1/0;e.boundingBox||e.computeBoundingBox(),Ct.set(e.boundingBox.min,e.boundingBox.max,n),Ct.needsUpdate=!0;const c=t.geometry,l=c.attributes.position,u=c.index,d=e.attributes.position,f=e.index,p=$.getPrimitive(),h=$.getPrimitive();let y=Lt,g=Nt,x=null,m=null;o&&(x=Xt,m=Ot);let w=1/0,B=null,v=null;return qt.copy(n).invert(),Et.matrix.copy(qt),t.shapecast({boundsTraverseOrder:t=>Ct.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<a&&(e&&(Et.min.copy(t.min),Et.max.copy(t.max),Et.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>Et.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<a,intersectsRange:(e,o)=>{for(let s=e,a=e+o;s<a;s++){xt(h,3*s,f,d),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){xt(p,3*e,u,l),p.needsUpdate=!0;const t=p.distanceToTriangle(h,y,x);if(t<w&&(g.copy(y),m&&m.copy(x),w=t,B=e,v=s),t<i)return!0}}}})}for(let o=0,a=s(e);o<a;o++){xt(h,3*o,f,d),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){xt(p,3*e,u,l),p.needsUpdate=!0;const t=p.distanceToTriangle(h,y,x);if(t<w&&(g.copy(y),m&&m.copy(x),w=t,B=e,v=o),t<i)return!0}}}}),$.releasePrimitive(p),$.releasePrimitive(h),w===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=w,r.faceIndex=B,o&&(o.point?o.point.copy(m):o.point=m.clone(),o.point.applyMatrix4(qt),g.applyMatrix4(qt),o.distance=g.sub(o.point).length(),o.faceIndex=v),r)}function Ht(t,e,n,r,o,i,s){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let u=t,d=e+t;u<d;u++){let t;if(t=n.resolveTriangleIndex(u),xt(s,3*t,c,l),s.needsUpdate=!0,r(s,t,o,i))return!0}return!1}function Rt(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let s,a,c,l,u=0;const d=t._roots;for(let i=0,p=d.length;i<p;i++)s=d[i],a=new Uint32Array(s),c=new Uint16Array(s),l=new Float32Array(s),f(0,u),u+=s.byteLength;function f(n,s){let u=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const d=2*n;if(c[d+15]===i.BE){const e=a[n+6];let i=1/0,s=1/0,u=1/0,f=-1/0,p=-1/0,h=-1/0;for(let n=e,a=e+c[d+14];n<a;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=r?r[n]:n;const a=o.getX(n),c=o.getY(n),l=o.getZ(n);a<i&&(i=a),a>f&&(f=a),c<s&&(s=c),c>p&&(p=c),l<u&&(u=l),l>h&&(h=l)}}return(l[n+0]!==i||l[n+1]!==s||l[n+2]!==u||l[n+3]!==f||l[n+4]!==p||l[n+5]!==h)&&(l[n+0]=i,l[n+1]=s,l[n+2]=u,l[n+3]=f,l[n+4]=p,l[n+5]=h,!0)}{const t=n+8,r=a[n+6],o=t+s,i=r+s;let c=u,d=!1,p=!1;e?c||(d=e.has(o),p=e.has(i),c=!d&&!p):(d=!0,p=!0);const h=c||p;let y=!1;(c||d)&&(y=f(t,s,c));let g=!1;h&&(g=f(r,s,c));const x=y||g;if(x)for(let e=0;e<3;e++){const o=t+e,i=r+e,s=l[o],a=l[o+3],c=l[i],u=l[i+3];l[n+e]=s<c?s:c,l[n+e+3]=a>u?a:u}return x}}}function Dt(t,e,n,r,o,i,s){J.setBuffer(t._roots[e]),jt(0,t,n,r,o,i,s),J.clearBuffer()}function jt(t,e,n,r,o,i,s){const{float32Array:a,uint16Array:c,uint32Array:l}=J,u=2*t;if(T(u,c)){!function(t,e,n,r,o,i,s,a){const{geometry:c,_indirectBuffer:l}=t;for(let u=r,d=r+o;u<d;u++)gt(c,e,n,l?l[u]:u,i,s,a)}(e,n,r,P(t,l),M(u,c),o,i,s)}else{const c=V(t);Bt(c,a,r,i,s)&&jt(c,e,n,r,o,i,s);const u=U(t,l);Bt(u,a,r,i,s)&&jt(u,e,n,r,o,i,s)}}const Gt=["x","y","z"];function Yt(t,e,n,r,o,i){J.setBuffer(t._roots[e]);const s=Zt(0,t,n,r,o,i);return J.clearBuffer(),s}function Zt(t,e,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:c}=J;let l=2*t;if(T(l,a)){return function(t,e,n,r,o,i,s){const{geometry:a,_indirectBuffer:c}=t;let l=1/0,u=null;for(let d=r,f=r+o;d<f;d++){let t;t=gt(a,e,n,c?c[d]:d,null,i,s),t&&t.distance<l&&(u=t,l=t.distance)}return u}(e,n,r,P(t,c),M(l,a),o,i)}{const a=S(t,c),l=Gt[a],u=r.direction[l]>=0;let d,f;u?(d=V(t),f=U(t,c)):(d=U(t,c),f=V(t));const p=Bt(d,s,r,o,i)?Zt(d,e,n,r,o,i):null;if(p){const t=p.point[l];if(u?t<=s[f+a]:t>=s[f+a+3])return p}const h=Bt(f,s,r,o,i)?Zt(f,e,n,r,o,i):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const $t=new r.Box3,Jt=new j,Qt=new j,Wt=new r.Matrix4,Kt=new G,te=new G;function ee(t,e,n,r){J.setBuffer(t._roots[e]);const o=ne(0,t,n,r);return J.clearBuffer(),o}function ne(t,e,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const{float32Array:i,uint16Array:s,uint32Array:a}=J;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),Kt.set(n.boundingBox.min,n.boundingBox.max,r),o=Kt);if(!T(c,s)){const s=t+8,c=a[t+6];d(s,i,$t);if(o.intersectsBox($t)&&ne(s,e,n,r,o))return!0;d(c,i,$t);return!!(o.intersectsBox($t)&&ne(c,e,n,r,o))}{const o=e.geometry,l=o.index,u=o.attributes.position,f=n.index,p=n.attributes.position,h=P(t,a),y=M(c,s);if(Wt.copy(r).invert(),n.boundsTree){d(t,i,te),te.matrix.copy(Wt),te.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>te.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let n=h,r=y+h;n<r;n++)if(xt(Qt,3*e.resolveTriangleIndex(n),l,u),Qt.needsUpdate=!0,t.intersectsTriangle(Qt))return!0;return!1}})}for(let t=h,n=y+h;t<n;t++){const n=e.resolveTriangleIndex(t);xt(Jt,3*n,l,u),Jt.a.applyMatrix4(Wt),Jt.b.applyMatrix4(Wt),Jt.c.applyMatrix4(Wt),Jt.needsUpdate=!0;for(let t=0,e=f.count;t<e;t+=3)if(xt(Qt,t,f,p),Qt.needsUpdate=!0,Jt.intersectsTriangle(Qt))return!0}}}const re=new r.Matrix4,oe=new G,ie=new G,se=new r.Vector3,ae=new r.Vector3,ce=new r.Vector3,le=new r.Vector3;function ue(t,e,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1/0;e.boundingBox||e.computeBoundingBox(),oe.set(e.boundingBox.min,e.boundingBox.max,n),oe.needsUpdate=!0;const c=t.geometry,l=c.attributes.position,u=c.index,d=e.attributes.position,f=e.index,p=$.getPrimitive(),h=$.getPrimitive();let y=se,g=ae,x=null,m=null;o&&(x=ce,m=le);let w=1/0,B=null,v=null;return re.copy(n).invert(),ie.matrix.copy(re),t.shapecast({boundsTraverseOrder:t=>oe.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<a&&(e&&(ie.min.copy(t.min),ie.max.copy(t.max),ie.needsUpdate=!0),!0),intersectsRange:(r,o)=>{if(e.boundsTree){const s=e.boundsTree;return s.shapecast({boundsTraverseOrder:t=>ie.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<a,intersectsRange:(e,a)=>{for(let c=e,b=e+a;c<b;c++){const e=s.resolveTriangleIndex(c);xt(h,3*e,f,d),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let n=r,s=r+o;n<s;n++){const e=t.resolveTriangleIndex(n);xt(p,3*e,u,l),p.needsUpdate=!0;const r=p.distanceToTriangle(h,y,x);if(r<w&&(g.copy(y),m&&m.copy(x),w=r,B=n,v=c),r<i)return!0}}}})}for(let a=0,c=s(e);a<c;a++){xt(h,3*a,f,d),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=r,n=r+o;e<n;e++){const n=t.resolveTriangleIndex(e);xt(p,3*n,u,l),p.needsUpdate=!0;const r=p.distanceToTriangle(h,y,x);if(r<w&&(g.copy(y),m&&m.copy(x),w=r,B=e,v=a),r<i)return!0}}}}),$.releasePrimitive(p),$.releasePrimitive(h),w===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=w,r.faceIndex=B,o&&(o.point?o.point.copy(m):o.point=m.clone(),o.point.applyMatrix4(re),g.applyMatrix4(re),o.distance=g.sub(o.point).length(),o.faceIndex=v),r)}const de=new J.constructor,fe=new J.constructor,pe=new Y((()=>new r.Box3)),he=new r.Box3,ye=new r.Box3,ge=new r.Box3,xe=new r.Box3;let me=!1;function we(t,e,n,r,o){let i,s,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,f=arguments.length>9&&void 0!==arguments[9]?arguments[9]:null,p=arguments.length>10&&void 0!==arguments[10]&&arguments[10];p?(i=fe,s=de):(i=de,s=fe);const h=i.float32Array,y=i.uint32Array,g=i.uint16Array,x=s.float32Array,m=s.uint32Array,w=s.uint16Array,B=2*e,v=T(2*t,g),b=T(B,w);let A=!1;if(b&&v)A=p?o(P(e,m),M(2*e,w),P(t,y),M(2*t,g),u,c+e,l,a+t):o(P(t,y),M(2*t,g),P(e,m),M(2*e,w),l,a+t,u,c+e);else if(b){const i=pe.getPrimitive();d(e,x,i),i.applyMatrix4(n);const s=V(t),f=U(t,y);d(s,h,he),d(f,h,ye);const g=i.intersectsBox(he),m=i.intersectsBox(ye);A=g&&we(e,s,r,n,o,c,a,u,l+1,i,!p)||m&&we(e,f,r,n,o,c,a,u,l+1,i,!p),pe.releasePrimitive(i)}else{const i=V(e),s=U(e,m);d(i,x,ge),d(s,x,xe);const g=f.intersectsBox(ge),w=f.intersectsBox(xe);if(g&&w)A=we(t,i,n,r,o,a,c,l,u+1,f,p)||we(t,s,n,r,o,a,c,l,u+1,f,p);else if(g)if(v)A=we(t,i,n,r,o,a,c,l,u+1,f,p);else{const e=pe.getPrimitive();e.copy(ge).applyMatrix4(n);const s=V(t),f=U(t,y);d(s,h,he),d(f,h,ye);const g=e.intersectsBox(he),x=e.intersectsBox(ye);A=g&&we(i,s,r,n,o,c,a,u,l+1,e,!p)||x&&we(i,f,r,n,o,c,a,u,l+1,e,!p),pe.releasePrimitive(e)}else if(w)if(v)A=we(t,s,n,r,o,a,c,l,u+1,f,p);else{const e=pe.getPrimitive();e.copy(xe).applyMatrix4(n);const i=V(t),f=U(t,y);d(i,h,he),d(f,h,ye);const g=e.intersectsBox(he),x=e.intersectsBox(ye);A=g&&we(s,i,r,n,o,c,a,u,l+1,e,!p)||x&&we(s,f,r,n,o,c,a,u,l+1,e,!p),pe.releasePrimitive(e)}}return A}const Be=new G,ve=new r.Box3,be={strategy:i.Q7,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class Ae{static serialize(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,o=t._indirectBuffer,i=n.getIndex();let s;return s=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:i?i.array.slice():null,indirectBuffer:o?o.slice():null}:{roots:r,index:i?i.array:null,indirectBuffer:o},s}static deserialize(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n={setIndex:!0,indirect:Boolean(t.indirectBuffer),...n};const{index:o,roots:s,indirectBuffer:a}=t,c=new Ae(e,{...n,[i.vl]:!0});if(c._roots=s,c._indirectBuffer=a||null,n.setIndex){const n=e.getIndex();if(null===n){const n=new r.BufferAttribute(t.index,1,!1);e.setIndex(n)}else n.array!==o&&(n.array.set(o),n.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if(e=Object.assign({...be,[i.vl]:!1},e),e.useSharedArrayBuffer&&"undefined"===typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[i.vl]||(X(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new r.Box3))),this.resolveTriangleIndex=e.indirect?t=>this._indirectBuffer[t]:t=>t}refit(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return(this.indirect?Rt:wt)(this,t)}traverse(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this._roots[e],r=new Uint32Array(n),o=new Uint16Array(n);!function e(s){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const c=2*s,l=o[c+15]===i.BE;if(l){const e=r[s+6],i=o[c+14];t(a,l,new Float32Array(n,4*s,6),e,i)}else{const o=s+i.Ne/4,c=r[s+6],u=r[s+7];t(a,l,new Float32Array(n,4*s,6),u)||(e(o,a+1),e(c,a+1))}}(0)}raycast(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:r.FrontSide,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;const i=this._roots,s=this.geometry,a=[],c=e.isMaterial,l=Array.isArray(e),u=s.groups,d=c?e.side:e,f=this.indirect?Dt:vt;for(let r=0,p=i.length;r<p;r++){const i=l?e[u[r].materialIndex].side:d,s=a.length;if(f(this,r,i,t,a,n,o),l){const t=u[r].materialIndex;for(let e=s,n=a.length;e<n;e++)a[e].face.materialIndex=t}}return a}raycastFirst(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:r.FrontSide,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;const i=this._roots,s=this.geometry,a=e.isMaterial,c=Array.isArray(e);let l=null;const u=s.groups,d=a?e.side:e,f=this.indirect?Yt:Tt;for(let r=0,p=i.length;r<p;r++){const i=f(this,r,c?e[u[r].materialIndex].side:d,t,n,o);null!=i&&(null==l||i.distance<l.distance)&&(l=i,c&&(i.face.materialIndex=u[r].materialIndex))}return l}intersectsGeometry(t,e){let n=!1;const r=this._roots,o=this.indirect?ee:It;for(let i=0,s=r.length;i<s&&(n=o(this,i,t,e),!n);i++);return n}shapecast(t){const e=$.getPrimitive(),n=this.indirect?Ht:mt;let{boundsTraverseOrder:r,intersectsBounds:o,intersectsRange:i,intersectsTriangle:s}=t;if(i&&s){const t=i;i=(r,o,i,a,c)=>!!t(r,o,i,a,c)||n(r,o,this,s,i,a,e)}else i||(i=s?(t,r,o,i)=>n(t,r,this,s,o,i,e):(t,e,n)=>n);let a=!1,c=0;const l=this._roots;for(let u=0,d=l.length;u<d;u++){const t=l[u];if(a=et(this,u,o,i,r,c),a)break;c+=t.byteLength}return $.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:o,intersectsTriangles:i}=n;const s=$.getPrimitive(),a=this.geometry.index,c=this.geometry.attributes.position,l=this.indirect?t=>{const e=this.resolveTriangleIndex(t);xt(s,3*e,a,c)}:t=>{xt(s,3*t,a,c)},u=$.getPrimitive(),f=t.geometry.index,p=t.geometry.attributes.position,h=t.indirect?e=>{const n=t.resolveTriangleIndex(e);xt(u,3*n,f,p)}:t=>{xt(u,3*t,f,p)};if(i){const t=(t,n,r,o,a,c,d,f)=>{for(let p=r,y=r+o;p<y;p++){h(p),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(l(e),s.needsUpdate=!0,i(s,u,e,p,a,c,d,f))return!0}return!1};if(o){const e=o;o=function(n,r,o,i,s,a,c,l){return!!e(n,r,o,i,s,a,c,l)||t(n,r,o,i,s,a,c,l)}}else o=t}return function(t,e,n,o){if(me)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");me=!0;const i=t._roots,s=e._roots;let a,c=0,l=0;const u=(new r.Matrix4).copy(n).invert();for(let r=0,f=i.length;r<f;r++){de.setBuffer(i[r]),l=0;const t=pe.getPrimitive();d(0,de.float32Array,t),t.applyMatrix4(u);for(let e=0,i=s.length;e<i&&(fe.setBuffer(s[r]),a=we(0,0,n,u,o,c,l,0,0,t),fe.clearBuffer(),l+=s[e].length,!a);e++);if(pe.releasePrimitive(t),de.clearBuffer(),c+=i[r].length,a)break}return me=!1,a}(this,t,e,o)}intersectsBox(t,e){return Be.set(t.min,t.max,e),Be.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Be.intersectsBox(t),intersectsTriangle:t=>Be.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1/0;return(this.indirect?ue:kt)(this,t,e,n,r,o,i)}closestPointToPoint(t){return function(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1/0;const i=r*r,s=o*o;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(rt.copy(e).clamp(t.min,t.max),rt.distanceToSquared(e)),intersectsBounds:(t,e,n)=>n<a&&n<s,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,rt);const r=e.distanceToSquared(rt);return r<a&&(ot.copy(rt),a=r,c=n),r<i}}),a===1/0)return null;const l=Math.sqrt(a);return n.point?n.point.copy(ot):n.point=ot.clone(),n.distance=l,n.faceIndex=c,n}(this,t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{d(0,new Float32Array(e),ve),t.union(ve)})),t}}const Te=new r.Ray,Pe=new r.Vector3,Me=new r.Matrix4,Ve=r.Mesh.prototype.raycast,Ue=new r.Vector3;function Se(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;Me.copy(this.matrixWorld).invert(),Te.copy(t.ray).applyMatrix4(Me),function(t,e){const n=t.elements,r=e.set(n[0],n[1],n[2]).length(),o=e.set(n[4],n[5],n[6]).length(),i=e.set(n[8],n[9],n[10]).length();e.set(r,o,i)}(this.matrixWorld,Ue),Pe.copy(Te.direction).multiply(Ue);const n=Pe.length(),r=t.near/n,i=t.far/n,s=this.geometry.boundsTree;if(!0===t.firstHitOnly){const n=o(s.raycastFirst(Te,this.material,r,i),this,t);n&&e.push(n)}else{const n=s.raycast(Te,this.material,r,i);for(let r=0,i=n.length;r<i;r++){const i=o(n[r],this,t);i&&e.push(i)}}}else Ve.call(this,t,e)}function Fe(t){return this.boundsTree=new Ae(this,t),this.boundsTree}function _e(){this.boundsTree=null}}}]);
//# sourceMappingURL=vendor.three-mesh-bvh.f7cc4348.js.map