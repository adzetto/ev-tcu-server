{"version":3,"file":"static/js/vendor.three-mesh-bvh.f7cc4348.js","mappings":"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","sources":["../node_modules/three-mesh-bvh/src/core/Constants.js","../node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js","../node_modules/three-mesh-bvh/src/core/build/geometryUtils.js","../node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js","../node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","../node_modules/three-mesh-bvh/src/core/build/splitUtils.js","../node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","../node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js","../node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js","../node_modules/three-mesh-bvh/src/core/build/buildUtils.js","../node_modules/three-mesh-bvh/src/core/build/buildTree.js","../node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","../node_modules/three-mesh-bvh/src/math/MathUtilities.js","../node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","../node_modules/three-mesh-bvh/src/math/OrientedBox.js","../node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","../node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js","../node_modules/three-mesh-bvh/src/core/utils/BufferStack.js","../node_modules/three-mesh-bvh/src/core/cast/shapecast.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js","../node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","../node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","../node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js","../node_modules/three-mesh-bvh/src/core/cast/refit.generated.js","../node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js","../node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js","../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js","../node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js","../node_modules/three-mesh-bvh/src/core/cast/bvhcast.js","../node_modules/three-mesh-bvh/src/core/MeshBVH.js","../node_modules/three-mesh-bvh/src/utils/BufferUtils.js","../node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js"],"sourcesContent":["// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n","// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\treturn hit;\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n","import { FLOAT32_EPSILON } from '../Constants.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, target = null, offset = null, count = null ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst normalized = posAttr.normalized;\n\tlet triangleBounds;\n\tif ( target === null ) {\n\n\t\ttriangleBounds = new Float32Array( triCount * 6 * 4 );\n\t\toffset = 0;\n\t\tcount = triCount;\n\n\t} else {\n\n\t\ttriangleBounds = target;\n\t\toffset = offset || 0;\n\t\tcount = count || triCount;\n\n\t}\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = offset; tri < offset + count; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\tthis.boundingData = new Float32Array( 6 );\n\n\t}\n\n}\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t}\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition };\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { IS_LEAF } from '../utils/nodeBufferUtils.js';\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow( 2, 32 );\n\nexport function countNodes( node ) {\n\n\tif ( 'count' in node ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t}\n\n}\n\nexport function populateBuffer( byteOffset, node, buffer ) {\n\n\tfloat32Array = new Float32Array( buffer );\n\tuint32Array = new Uint32Array( buffer );\n\tuint16Array = new Uint16Array( buffer );\n\tuint8Array = new Uint8Array( buffer );\n\n\treturn _populateBuffer( byteOffset, node );\n\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer( byteOffset, node ) {\n\n\tconst stride4Offset = byteOffset / 4;\n\tconst stride2Offset = byteOffset / 2;\n\tconst isLeaf = 'count' in node;\n\tconst boundingData = node.boundingData;\n\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t}\n\n\tif ( isLeaf ) {\n\n\t\tif ( node.buffer ) {\n\n\t\t\tconst buffer = node.buffer;\n\t\t\tuint8Array.set( new Uint8Array( buffer ), byteOffset );\n\n\t\t\tfor ( let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE ) {\n\n\t\t\t\tconst offset2 = offset / 2;\n\t\t\t\tif ( ! IS_LEAF( offset2, uint16Array ) ) {\n\n\t\t\t\t\tuint32Array[ ( offset / 4 ) + 6 ] += stride4Offset;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteOffset + buffer.byteLength;\n\n\t\t} else {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = node.left;\n\t\tconst right = node.right;\n\t\tconst splitAxis = node.splitAxis;\n\n\t\tlet nextUnusedPointer;\n\t\tnextUnusedPointer = _populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\tif ( ( nextUnusedPointer / 4 ) > MAX_POINTER ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t}\n\n\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\tnextUnusedPointer = _populateBuffer( nextUnusedPointer, right );\n\n\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\treturn nextUnusedPointer;\n\n\t}\n\n}\n","import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport function buildTree( bvh, triangleBounds, offset, count, options ) {\n\n\t// epxand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafTris,\n\t\tstrategy,\n\t\tonProgress,\n\t\tindirect,\n\t} = options;\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst partionFunc = indirect ? partition_indirect : partition;\n\n\t// generate intermediate variables\n\tconst totalTriangles = getTriCount( geometry );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new MeshBVHNode();\n\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\tconst triangleBounds = computeTriangleBounds( geometry );\n\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\n\tbvh._roots = geometryRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\tconst tempPoint = new Vector3();\n\n\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t// find the edge that intersects the other triangle plane\n\t\tconst points = tri.points;\n\t\tlet count = 0;\n\t\tlet startPointIntersection = - 1;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst { start, end } = edge;\n\t\t\tstart.copy( points[ i ] );\n\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\tedge.delta( dir );\n\n\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\tcount = 2;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\ttempPoint.copy( start );\n\n\t\t\t}\n\n\t\t\t// ignore the end point\n\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t// the start point if necessary\n\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcount ++;\n\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = new _BufferStack();\n","import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side, near, far ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\tif ( distance < near || distance > far ) return null;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections, near, far ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst index = geo.index;\n\tif ( geo.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, side, ray, i, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, side, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, side, ray, i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */\nexport function intersectRay( nodeIndex32, array, ray, near, far ) {\n\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\tconst invdirx = 1 / ray.direction.x,\n\t\tinvdiry = 1 / ray.direction.y,\n\t\tinvdirz = 1 / ray.direction.z;\n\n\tconst ox = ray.origin.x;\n\tconst oy = ray.origin.y;\n\tconst oz = ray.origin.z;\n\n\tlet minx = array[ nodeIndex32 ];\n\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\tlet miny = array[ nodeIndex32 + 1 ];\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\tlet minz = array[ nodeIndex32 + 2 ];\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\tif ( invdirx >= 0 ) {\n\n\t\ttmin = ( minx - ox ) * invdirx;\n\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t} else {\n\n\t\ttmin = ( maxx - ox ) * invdirx;\n\t\ttmax = ( minx - ox ) * invdirx;\n\n\t}\n\n\tif ( invdiry >= 0 ) {\n\n\t\ttymin = ( miny - oy ) * invdiry;\n\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t} else {\n\n\t\ttymin = ( maxy - oy ) * invdiry;\n\t\ttymax = ( miny - oy ) * invdiry;\n\n\t}\n\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\tif ( invdirz >= 0 ) {\n\n\t\ttzmin = ( minz - oz ) * invdirz;\n\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t} else {\n\n\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t}\n\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t//return point closest to the ray (positive side)\n\n\treturn tmin <= far && tmax >= near;\n\n}\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast( bvh, root, side, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst( bvh, root, side, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t// eslint-disable-next-line no-unreachable\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, side, ray, vi, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast_indirect( bvh, root, side, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst_indirect( bvh, root, side, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\n\nconst _bufferStack1 = new BufferStack.constructor();\nconst _bufferStack2 = new BufferStack.constructor();\nconst _boxPool = new PrimitivePool( () => new Box3() );\nconst _leftBox1 = new Box3();\nconst _rightBox1 = new Box3();\n\nconst _leftBox2 = new Box3();\nconst _rightBox2 = new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet offset1 = 0;\n\tlet offset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\toffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ i ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\toffset1 += roots[ i ].length;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexByteOffset = 0,\n\tnode2IndexByteOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n","import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafTris: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n};\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\t...DEFAULT_OPTIONS,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects, near, far );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray, near, far );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToBufferType( array, BufferConstructor ) {\n\n\tif ( array === null ) {\n\n\t\treturn array;\n\n\t} else if ( array.buffer ) {\n\n\t\tconst buffer = array.buffer;\n\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst ArrayConstructor = array.constructor;\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\tresult.set( array );\n\t\treturn result;\n\n\t} else {\n\n\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst result = new BufferConstructor( array.byteLength );\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\treturn result;\n\n\t}\n\n}\n","import { Ray, Matrix4, Mesh, Vector3 } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst ray = /* @__PURE__ */ new Ray();\nconst direction = /* @__PURE__ */ new Vector3();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\nconst _worldScale = /* @__PURE__ */ new Vector3();\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\textractMatrixScale( this.matrixWorld, _worldScale );\n\t\tdirection.copy( ray.direction ).multiply( _worldScale );\n\n\t\tconst scaleFactor = direction.length();\n\t\tconst near = raycaster.near / scaleFactor;\n\t\tconst far = raycaster.far / scaleFactor;\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material, near, far ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material, near, far );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js#L732\n// extracting the scale directly is ~3x faster than using \"decompose\"\nfunction extractMatrixScale( matrix, target ) {\n\n\tconst te = matrix.elements;\n\tconst sx = target.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\tconst sy = target.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\tconst sz = target.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\treturn target.set( sx, sy, sz );\n\n}\n"],"names":["CENTER","AVERAGE","SAH","CONTAINED","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","BYTES_PER_NODE","IS_LEAFNODE_FLAG","FLOAT32_EPSILON","Math","pow","SKIP_GENERATION","Symbol","convertRaycastIntersect","hit","object","raycaster","point","applyMatrix4","matrixWorld","distance","distanceTo","ray","origin","getTriCount","geo","index","count","attributes","position","getVertexCount","ensureIndex","options","vertexCount","BufferConstructor","arguments","length","undefined","ArrayBuffer","Uint32Array","Uint16Array","getIndexArray","useSharedArrayBuffer","SharedArrayBuffer","setIndex","BufferAttribute","i","getFullGeometryRange","triCount","drawRange","start","end","offset","max","min","floor","getRootIndexRanges","groups","ranges","rangeBoundaries","Set","drawRangeStart","drawRangeEnd","group","groupStart","groupEnd","add","sortedBoundaries","Array","from","values","sort","a","b","push","getBounds","triangleBounds","target","centroidTarget","minx","Infinity","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","arrayToBox","nodeIndex32","array","x","y","z","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","dist","copyBounds","source","set","unionBounds","aVal","bVal","d","d3","expandByTriangleBounds","startIndex","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","BIN_COUNT","binsSort","candidate","sahBins","fill","map","Float32Array","rightCacheBounds","leftCacheBounds","leftBounds","MeshBVHNode","constructor","this","boundingData","partition","indirectBuffer","split","left","right","pos","axisOffset","axis","t0","tb","partition_indirect","t","IS_LEAF","n16","uint16Array","OFFSET","n32","uint32Array","COUNT","LEFT_NODE","RIGHT_NODE","SPLIT_AXIS","float32Array","uint8Array","MAX_POINTER","countNodes","node","populateBuffer","byteOffset","buffer","Uint8Array","_populateBuffer","stride4Offset","stride2Offset","isLeaf","l","byteLength","splitAxis","nextUnusedPointer","Error","buildTree","bvh","maxDepth","verbose","maxLeafTris","strategy","onProgress","indirect","_indirectBuffer","geometry","indexArray","partionFunc","totalTriangles","cacheCentroidBoundingData","reachedMaxDepth","root","splitNode","centroidBoundingData","depth","console","warn","triggerProgress","nodeBoundingData","avg","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","truncatedBins","c","bin","splitCount","bi","splice","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","getOptimalSplit","splitOffset","lstart","lcount","rstart","rcount","trianglesProcessed","buildPackedTree","useUint32","byteCount","generateIndirectBuffer","finalGroup","total","forEach","_ref","hasGroupGaps","posAttr","normalized","posArr","bufferOffset","stride","isInterleavedBufferAttribute","data","getters","tri","tri3","tri6","ai","ci","el","halfExtents","el2","abs","computeTriangleBounds","geometryRanges","_roots","range","nodeCount","SeparatingAxisBounds","setFromPointsField","points","field","val","setFromPoints","p","dot","isSeparated","other","prototype","setFromBox","Vector3","box","boxMin","boxMax","cacheSatBounds","closestPointLineToLine","dir1","dir2","v02","l1","l2","result","v0","v10","v2","v32","subVectors","d0232","d3210","d3232","d0210","denom","closestPointsSegmentToSegment","paramResult","Vector2","temp1","temp2","target1","target2","at","closestPointToPoint","p2","closestPoint","closestPoint2","distanceToSquared","copy","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","plane","getPlane","distanceToPoint","pp","projectPoint","containsPoint","isNearZero","value","ExtendedTriangle","Triangle","super","isExtendedTriangle","satAxes","satBounds","Sphere","needsUpdate","intersectsSphere","update","axis0","sab0","getNormal","axis1","sab1","axis2","sab2","axis3","sab3","setFromNormalAndCoplanarPoint","closestPointToSegment","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","sqrt","intersectsTriangle","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","dir","tempDir","edge1","edge2","tempPoint","triIntersectPlane","targetEdge","startPointIntersection","delta","startIntersects","normal","doesIntersect","intersectLine","suppressLog","plane1","plane2","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","sa1","i2","sa2","crossVectors","count1","count2","tmp","s1","e1","s2","e2","distanceToTriangle","cornerFields","line1","line2","lineTarget","getCenter","otherVec","thisVec","f11","f12","f21","f22","OrientedBox","matrix","isOrientedBox","Matrix4","invMatrix","alignedSatBounds","v","minVec","pi","invert","intersectsBox","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","clamp","distanceToBox","xyzFields","segments1","segments2","threshold","threshold2","i1","nextIndex","nextIndex2","index2","p1","f1","f2","f3","PrimitivePool","getNewPrimitive","_getNewPrimitive","_primitives","getPrimitive","primitives","pop","releasePrimitive","primitive","ExtendedTrianglePoolBase","ExtendedTrianglePool","BufferStack","stack","prevBuffer","setBuffer","clearBuffer","_box1","_box2","boxStack","boxPool","Box3","shapecast","intersectsBounds","intersectsRange","boundsTraverseOrder","shapecastTraverse","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","nodeIndex16","score1","score2","box1","box2","c1","c2","temp","c1Intersection","c1StopTraversal","getLeftOffset","getRightEndOffset","c2Intersection","c2StopTraversal","_vA","_vB","_vC","_uvA","_uvB","_uvC","_normalA","_normalB","_normalC","_intersectionPoint","checkBufferGeometryIntersection","uv","uv1","side","near","far","fromBufferAttribute","intersection","pA","pB","pC","intersect","BackSide","intersectTriangle","DoubleSide","clone","checkIntersection","getInterpolation","direction","multiplyScalar","face","materialIndex","faceIndex","intersectTri","intersections","triOffset","getX","setTriangle","ta","tc","i0","getY","getZ","iterateOverTriangles","intersectsTriangleFunc","contained","refit","nodeIndices","isArray","indexArr","roots","_traverse","node32Index","force","node16Index","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","intersectRay","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","ox","oy","oz","isNaN","raycast","intersects","_raycast","intersectTris","leftIndex","rightIndex","_xyzFields","raycastFirst","_raycastFirst","res","intersectClosestTri","xyzAxis","leftToRight","c1Result","c2Result","boundingBox","triangle2","invertedMat","obb","obb2","intersectsGeometry","otherGeometry","geometryToBvh","_intersectsGeometry","cachedObb","computeBoundingBox","thisGeometry","thisIndex","thisPos","boundsTree","tempMatrix","temp3","temp4","closestPointToGeometry","minThreshold","maxThreshold","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","score","otherOffset","otherCount","sub","iterateOverTriangles_indirect","resolveTriangleIndex","refit_indirect","j","raycast_indirect","intersectTris_indirect","raycastFirst_indirect","intersectClosestTri_indirect","intersectsGeometry_indirect","ti","closestPointToGeometry_indirect","otherBvh","ti2","_bufferStack1","_bufferStack2","_boxPool","_leftBox1","_rightBox1","_leftBox2","_rightBox2","_active","node1Index32","node2Index32","matrix2to1","matrix1to2","intersectsRangesFunc","bufferStack1","bufferStack2","node1IndexByteOffset","node2IndexByteOffset","depth1","depth2","currBox","reversed","float32Array1","uint32Array1","uint16Array1","float32Array2","uint32Array2","uint16Array2","node2Index16","isLeaf1","isLeaf2","newBox","cl1","cr1","intersectCl1","intersectCr1","cl2","cr2","leftIntersects","rightIntersects","tempBox","DEFAULT_OPTIONS","setBoundingBox","MeshBVH","serialize","cloneBuffers","rootData","indexAttribute","getIndex","slice","deserialize","Boolean","newIndex","isBufferGeometry","Object","assign","getBoundingBox","traverse","callback","rootIndex","materialOrSide","FrontSide","isMaterial","isArrayMaterial","raycastFunc","materialSide","startCount","jl","closestResult","raycastFirstFunc","geomToMesh","intersectsGeometryFunc","callbacks","iterateFunc","originalIntersectsRange","nodeIndex","bvhcast","matrixToLocal","intersectsRanges","intersectsTriangles","triangle1","indexAttr1","positionAttr1","assignTriangle1","indexAttr2","positionAttr2","assignTriangle2","iterateOverDoubleTriangles","offset1","offset2","index1","originalIntersectsRanges","otherRoots","invMat","il","localBox","boxToMesh","minThresholdSq","maxThresholdSq","triIndex","makeEmpty","union","Ray","tmpInverseMatrix","origMeshRaycastFunc","Mesh","_worldScale","acceleratedRaycast","material","te","elements","sx","sy","sz","extractMatrixScale","multiply","scaleFactor","firstHitOnly","hits","call","computeBoundsTree","disposeBoundsTree"],"sourceRoot":""}